#include "Nano.h"
#include "rooutil.h"
#include "cxxopts.h"
#include "Base.h"
#include "ElectronSelections.h"
#include "MuonSelections.h"
#include "TauSelections.h"

#include "VBSHWW.h"

bool isPromptLepton(int lep_reco_flav, int lep_gen_part_flav_code)
{
    if (abs(lep_reco_flav) == 11 || abs(lep_reco_flav) == 13)
    {
        return (lep_gen_part_flav_code == 1);
    }
    else if (abs(lep_reco_flav) == 15)
    {
        return (lep_gen_part_flav_code >= 3);
    }
    else
    {
        return false;
    }
}

// ./process INPUTFILEPATH OUTPUTFILE [NEVENTS]
int main(int argc, char** argv)
{

    VBSHWW vbs(argc, argv);

    // Real lepton branches
    vbs.tx.createBranch<int>("real_lep_id");
    vbs.tx.createBranch<float>("real_lep_pt");
    vbs.tx.createBranch<float>("real_lep_eta");
    vbs.tx.createBranch<float>("real_lep_phi");
    vbs.tx.createBranch<int>("real_lep_origin");
    vbs.tx.createBranch<bool>("real_lep_is_loose");
    vbs.tx.createBranch<bool>("real_lep_is_tight");
    // Fake lepton branches
    vbs.tx.createBranch<int>("fake_lep_id");
    vbs.tx.createBranch<float>("fake_lep_pt");
    vbs.tx.createBranch<float>("fake_lep_eta");
    vbs.tx.createBranch<float>("fake_lep_phi");
    vbs.tx.createBranch<int>("fake_lep_origin");
    vbs.tx.createBranch<bool>("fake_lep_is_loose");
    vbs.tx.createBranch<bool>("fake_lep_is_tight");
    // b-jets
    vbs.tx.createBranch<int>("n_gen_bquarks");
    vbs.tx.createBranch<int>("n_loose_bjets");
    vbs.tx.createBranch<int>("n_medium_bjets");
    vbs.tx.createBranch<int>("n_tight_bjets");
    // Other
    vbs.tx.createBranch<float>("event_weight");
    vbs.tx.createBranch<vector<int>>("good_leptons_genPartFlav");

    vbs.cutflow.getCut("Weight");
    vbs.cutflow.addCutToLastActiveCut(
        "SaveWeight",
        [&]()
        {
            float weight = ((nt.Generator_weight() > 0) - (nt.Generator_weight() < 0))*vbs.scale1fb;
            vbs.tx.setBranch<float>("event_weight", weight*gconf.lumi);
            return true;
        },
        UNITY
    );

    //*****************************
    // - Selecting Analysis Leptons
    //*****************************
    // Description: Select leptons used for the analysis
    //              The electrons / muons definitions are in NanoCORE/Electron(Muon)Selections.cc
    vbs.cutflow.addCutToLastActiveCut("SelectLeptons",
        [&]()
        {

            // Select muons
            for (unsigned int imu = 0; imu < nt.nMuon(); ++imu)
            {
                if (SS::muonID(imu, SS::IDfakable, nt.year()))
                {
                    vbs.tx.pushbackToBranch<LV>("good_leptons_p4", nt.Muon_p4()[imu]);
                    vbs.tx.pushbackToBranch<int>("good_leptons_genPartFlav", nt.Muon_genPartFlav()[imu]);
                    vbs.tx.pushbackToBranch<int>("good_leptons_pdgid", (-nt.Muon_charge()[imu]) * 13);
                    vbs.tx.pushbackToBranch<int>("good_leptons_tight", SS::muonID(imu, SS::IDtight, nt.year()));
                    vbs.tx.pushbackToBranch<int>("good_leptons_jetIdx", nt.Muon_jetIdx()[imu]);
                    vbs.tx.pushbackToBranch<float>("good_leptons_pfRelIso03_all", nt.Muon_pfRelIso03_all()[imu]);
                    vbs.tx.pushbackToBranch<float>("good_leptons_pfRelIso03_chg", -999);
                    vbs.tx.pushbackToBranch<float>("good_leptons_jetPtRelv2", nt.Muon_jetPtRelv2()[imu]);
                    vbs.tx.pushbackToBranch<float>("good_leptons_jetRelIso", nt.Muon_jetRelIso()[imu]);
                    vbs.tx.pushbackToBranch<float>("good_leptons_miniPFRelIso_all", nt.Muon_miniPFRelIso_all()[imu]);
                }
            }

            // Select electrons
            for (unsigned int iel = 0; iel < nt.nElectron(); ++iel)
            {
                if (SS::electronID(iel, SS::IDfakable, nt.year()))
                {
                    vbs.tx.pushbackToBranch<LV>("good_leptons_p4", nt.Electron_p4()[iel]);
                    vbs.tx.pushbackToBranch<int>("good_leptons_genPartFlav", nt.Electron_genPartFlav()[iel]);
                    vbs.tx.pushbackToBranch<int>("good_leptons_pdgid", (-nt.Electron_charge()[iel]) * 11);
                    vbs.tx.pushbackToBranch<int>("good_leptons_tight", SS::electronID(iel, SS::IDtight, nt.year()) * (nt.Electron_pfRelIso03_all()[iel] < 0.05));
                    vbs.tx.pushbackToBranch<int>("good_leptons_jetIdx", nt.Electron_jetIdx()[iel]);
                    vbs.tx.pushbackToBranch<float>("good_leptons_pfRelIso03_all", nt.Electron_pfRelIso03_all()[iel]);
                    vbs.tx.pushbackToBranch<float>("good_leptons_pfRelIso03_chg", nt.Electron_pfRelIso03_chg()[iel]);
                    vbs.tx.pushbackToBranch<float>("good_leptons_jetPtRelv2", nt.Electron_jetPtRelv2()[iel]);
                    vbs.tx.pushbackToBranch<float>("good_leptons_jetRelIso", nt.Electron_jetRelIso()[iel]);
                    vbs.tx.pushbackToBranch<float>("good_leptons_miniPFRelIso_all", nt.Electron_miniPFRelIso_all()[iel]);
                }
            }

            // Select taus
            vector<LV> good_leptons_p4 = vbs.tx.getBranchLazy<vector<LV>>("good_leptons_p4");
            vector<int> good_leptons_pdgid = vbs.tx.getBranchLazy<vector<int>>("good_leptons_pdgid");
            for (unsigned int itau = 0; itau < nt.nTau(); ++itau)
            {
                if (SS::tauID(itau, SS::IDfakable, nt.year()))
                {
                    // global pt cut of 20 GeV for taus
                    if (nt.Tau_pt().at(itau) < 20) { continue; }
                    // tau-(non-tau lep) overlap removal
                    if (SS::tauID(itau, SS::IDtight, nt.year()))
                    {
                        bool save_this_tau = true;
                        for (unsigned int ilep = 0; ilep < good_leptons_p4.size(); ++ilep)
                        {
                            if (RooUtil::Calc::DeltaR(nt.Tau_p4().at(itau), good_leptons_p4.at(ilep)) < 0.4)
                            {
                                save_this_tau = false;
                                break;
                            }
                        }
                        if (!save_this_tau) { continue; }
                    }
                    vbs.tx.pushbackToBranch<LV>("good_leptons_p4", nt.Tau_p4()[itau]);
                    vbs.tx.pushbackToBranch<int>("good_leptons_genPartFlav", nt.Tau_genPartFlav()[itau]);
                    vbs.tx.pushbackToBranch<int>("good_leptons_pdgid", (-nt.Tau_charge()[itau]) * 11);
                    vbs.tx.pushbackToBranch<int>("good_leptons_tight", SS::tauID(itau, SS::IDtight, nt.year()));
                    vbs.tx.pushbackToBranch<int>("good_leptons_jetIdx", nt.Tau_jetIdx()[itau]);
                    vbs.tx.pushbackToBranch<float>("good_leptons_pfRelIso03_all", -999.);
                    vbs.tx.pushbackToBranch<float>("good_leptons_pfRelIso03_chg", -999.);
                    vbs.tx.pushbackToBranch<float>("good_leptons_jetPtRelv2", -999.);
                    vbs.tx.pushbackToBranch<float>("good_leptons_jetRelIso", -999.);
                    vbs.tx.pushbackToBranch<float>("good_leptons_miniPFRelIso_all", -999.);
                }
            }

            vbs.tx.sortVecBranchesByPt(
                /* name of the 4vector branch to use to pt sort by*/
                "good_leptons_p4",
                /* names of any associated vector<float> branches to sort along */
                {
                    "good_leptons_pfRelIso03_all", 
                    "good_leptons_pfRelIso03_chg", 
                    "good_leptons_jetPtRelv2", 
                    "good_leptons_jetRelIso", 
                    "good_leptons_miniPFRelIso_all"
                },
                /* names of any associated vector<int>   branches to sort along */
                {"good_leptons_pdgid", "good_leptons_tight", "good_leptons_jetIdx"},
                /* names of any associated vector<bool>  branches to sort along */
                {}
             );

            return true;

        },
        UNITY);

    //*****************************
    // - Same Sign Preselection
    //*****************************
    // Description: Pass events only when we have:
    //              - two loose
    //              - two tight
    //              - they are same sign
    //              - pt > 25 or 20 depending on flavor (see below for detail)
    vbs.cutflow.addCutToLastActiveCut("DileptonPreselection",
        [&]()
        {

            // Select only two loose leptons
            if (not (vbs.tx.getBranchLazy<vector<LV>>("good_leptons_p4").size() == 2))
                return false;

//             int ntight = 0;
//             for (auto& istight : vbs.tx.getBranch<vector<int>>("good_leptons_tight"))
//             {
//                 if (istight)
//                     ntight++;
//             }

//             // Select only two tight leptons
//             if (not (ntight == 2))
//                 return false;

            return true;

            // // Therefore I will only have two leptons in the good_leptons container
            // const int& pdgid0 = vbs.tx.getBranch<vector<int>>("good_leptons_pdgid")[0];
            // const int& pdgid1 = vbs.tx.getBranch<vector<int>>("good_leptons_pdgid")[1];

            // // Require same sign
            // // if (not (pdgid0 * pdgid1 > 0))
            // //     return false;

            // const float& pt0 = vbs.tx.getBranch<vector<LV>>("good_leptons_p4")[0].pt();
            // const float& pt1 = vbs.tx.getBranch<vector<LV>>("good_leptons_p4")[1].pt();

            // // Apply Pt selections
            // if (abs(pdgid0) == 11 and abs(pdgid1) == 11)
            // {
            //     return ((pt0 > 25.) and (pt1 > 25.));
            // }
            // else if (abs(pdgid0) == 11 and abs(pdgid1) == 13)
            // {
            //     return ((pt0 > 25.) and (pt1 > 20.));
            // }
            // else if (abs(pdgid0) == 13 and abs(pdgid1) == 11)
            // {
            //     return ((pt0 > 25.) and (pt1 > 25.));
            // }
            // else if (abs(pdgid0) == 13 and abs(pdgid1) == 13)
            // {
            //     return ((pt0 > 25.) and (pt1 > 20.));
            // }
            // else
            // {
            //     // I should not be here
            //     std::cout << "I should not be here!!!! " << std::endl;
            //     return false;
            // }
        },
        UNITY);

    vbs.cutflow.addCutToLastActiveCut("FillLeptonBranches",
        [&]()
        {
            // Find prompt lepton
            const vector<int>& good_leptons_tight = vbs.tx.getBranchLazy<vector<int>>("good_leptons_tight");
            const vector<int>& good_leptons_pdgid = vbs.tx.getBranch<vector<int>>("good_leptons_pdgid");
            const vector<int>& good_leptons_genPartFlav = vbs.tx.getBranch<vector<int>>("good_leptons_genPartFlav");
            const vector<LV>& good_leptons_p4 = vbs.tx.getBranch<vector<LV>>("good_leptons_p4");
            int real_lep = (good_leptons_tight.at(0) == 1) ? 0 : 1;
            int fake_lep = (good_leptons_tight.at(0) == 1) ? 1 : 0;
            // Real lepton branches
            vbs.tx.setBranch<int>("real_lep_id", good_leptons_pdgid.at(real_lep));
            vbs.tx.setBranch<float>("real_lep_pt", good_leptons_p4.at(real_lep).pt());
            vbs.tx.setBranch<float>("real_lep_eta", good_leptons_p4.at(real_lep).eta());
            vbs.tx.setBranch<float>("real_lep_phi", good_leptons_p4.at(real_lep).phi());
            vbs.tx.setBranch<int>("real_lep_origin", good_leptons_genPartFlav.at(real_lep));
            vbs.tx.setBranch<bool>("real_lep_is_loose", !good_leptons_tight.at(real_lep));
            vbs.tx.setBranch<bool>("real_lep_is_tight", bool(good_leptons_tight.at(real_lep)));
            // Fake lepton branches
            vbs.tx.setBranch<int>("fake_lep_id", good_leptons_pdgid.at(fake_lep));
            vbs.tx.setBranch<float>("fake_lep_pt", good_leptons_p4.at(fake_lep).pt());
            vbs.tx.setBranch<float>("fake_lep_eta", good_leptons_p4.at(fake_lep).eta());
            vbs.tx.setBranch<float>("fake_lep_phi", good_leptons_p4.at(fake_lep).phi());
            vbs.tx.setBranch<int>("fake_lep_origin", good_leptons_genPartFlav.at(fake_lep));
            vbs.tx.setBranch<bool>("fake_lep_is_loose", !good_leptons_tight.at(fake_lep));
            vbs.tx.setBranch<bool>("fake_lep_is_tight", bool(good_leptons_tight.at(fake_lep)));
            return true;
        },
        UNITY);

    //*****************************
    // - Select Good Reco Jets
    //*****************************
    // Description: Select Good Reco Jets
    //              - (TODO?) CURRENTLY NO ID APPLIED TO THE JETS
    //              - TODO TODO TODO TODO : Check pileup jet ID for year 2017
    //              - Perform overlap removal against loose leptons
    //              - Accept jets above 20 GeV for the container
    //              - Count N btagged jets (nbloose, nbmedium, nbtight)
    //              - Count central and all jets with pt > 30 GeV
    //              - Save the jets into good_jets containers
    vbs.cutflow.addCutToLastActiveCut("SelectJets",
        [&]()
        {
            int n_gen_bquarks = 0;
            for (unsigned int idx = 0; idx < nt.nGenPart(); ++idx)
            {
                // Only look at electrons, muons, or taus
                if (abs(nt.GenPart_pdgId()[idx]) != 5)  { continue; }
                if (nt.GenPart_status()[idx] != 23) { continue; }
                // Try to find mother
                int mother_idx = nt.GenPart_genPartIdxMother()[idx];
                if (mother_idx < 0) { continue; }
                // Check if mother is a W
                if (abs(nt.GenPart_pdgId()[mother_idx]) == 6) { n_gen_bquarks++; }
            }
            vbs.tx.setBranch<int>("n_gen_bquarks", n_gen_bquarks);

            // b tagging counters
            int nbloose = 0;
            int nbmedium = 0;
            int nbtight = 0;

            int ncenjet30 = 0;
            int njet30 = 0;

            // Loop over the jets
            for (unsigned int ijet = 0; ijet < nt.Jet_pt().size(); ++ijet)
            {
                // Read jet p4
                const LV& jet_p4 = nt.Jet_p4()[ijet];

                // Overlap check against good leptons
                bool isOverlap = false;
                vector<LV> good_leptons_p4 = vbs.tx.getBranch<vector<LV>>("good_leptons_p4");
                vector<int> good_leptons_pdgid = vbs.tx.getBranch<vector<int>>("good_leptons_pdgid");
                vector<int> good_leptons_jetIdx = vbs.tx.getBranch<vector<int>>("good_leptons_jetIdx");
                for (unsigned int ilep = 0; ilep < good_leptons_p4.size(); ++ilep)
                {
                    bool lep_flav = good_leptons_pdgid.at(ilep);
                    if ((abs(lep_flav) != 15) && (good_leptons_jetIdx.at(ilep) == (int) ijet))
                    {
                        isOverlap = true;
                        break;
                    }
                    if ((abs(lep_flav) == 15) && (RooUtil::Calc::DeltaR(good_leptons_p4.at(ilep), jet_p4) < 0.4)) 
                    {
                        isOverlap = true;
                        break;
                    }
                }

                // Then skip
                if (isOverlap)
                    continue;

                // B-tagging is done down to 20 GeV
                if (not (jet_p4.pt() > 20.))
                    continue;

                bool is_loose_btagged = false;
                bool is_medium_btagged = false;
                bool is_tight_btagged = false;

                // B-tagging is also done up to 2.5 in eta only
                if (abs(jet_p4.eta()) < 2.4)
                {
                    // Check if it passes btagging
                    is_loose_btagged = nt.Jet_btagDeepFlavB()[ijet] > gconf.WP_DeepFlav_loose;
                    is_medium_btagged = nt.Jet_btagDeepFlavB()[ijet] > gconf.WP_DeepFlav_medium;
                    is_tight_btagged = nt.Jet_btagDeepFlavB()[ijet] > gconf.WP_DeepFlav_tight;

                    // Count up the btagging
                    if (is_loose_btagged) nbloose++;
                    if (is_medium_btagged) nbmedium++;
                    if (is_tight_btagged) nbtight++;
                }

                vbs.tx.pushbackToBranch<LV>("good_jets_p4", jet_p4);
                vbs.tx.pushbackToBranch<int>("good_jets_loose_btagged", is_loose_btagged);
                vbs.tx.pushbackToBranch<int>("good_jets_medium_btagged", is_medium_btagged);
                vbs.tx.pushbackToBranch<int>("good_jets_tight_btagged", is_tight_btagged);
                vbs.tx.pushbackToBranch<float>("good_jets_btag_score", nt.Jet_btagDeepFlavB()[ijet]);
                vbs.tx.pushbackToBranch<float>("good_jets_qg_disc", nt.Jet_qgl()[ijet]);

                if (abs(jet_p4.eta()) < 3.0 and jet_p4.pt() > 30.)
                {
                    ncenjet30 ++;
                }
                if (jet_p4.pt() > 30.)
                {
                    njet30 ++;
                }

            }

            vbs.tx.setBranch<int>("nbloose", nbloose);
            vbs.tx.setBranch<int>("nbmedium", nbmedium);
            vbs.tx.setBranch<int>("nbtight", nbtight);
            vbs.tx.setBranch<int>("ncenjet30", ncenjet30);
            vbs.tx.setBranch<int>("njet30", njet30);

            vbs.tx.sortVecBranchesByPt(
                /* name of the 4vector branch to use to pt sort by*/
                "good_jets_p4",
                /* names of any associated vector<float> branches to sort along */ 
                {"good_jets_btag_score", "good_jets_qg_disc"},
                /* names of any associated vector<int>   branches to sort along */ 
                {"good_jets_loose_btagged", "good_jets_medium_btagged", "good_jets_tight_btagged"},
                /* names of any associated vector<bool>  branches to sort along */ 
                {}
            );

            return true;
        },
        UNITY);

    //*****************************
    // - Require Two Medium Btag
    //*****************************
    // Description: Select two medium b-tag /* TODO TODO TODO TODO btag scale factor */
    vbs.cutflow.addCutToLastActiveCut("GeqTwoMedBtag", [&]() { return vbs.tx.getBranch<int>("nbmedium") >= 2; }, UNITY);

    //*****************************
    // - Require Two Tight Btag
    //*****************************
    // Description: Select two tight b-tag /* TODO TODO TODO TODO btag scale factor */
    vbs.cutflow.addCutToLastActiveCut("GeqTwoTightBtag", [&]() { return vbs.tx.getBranch<int>("nbtight") >= 2; }, UNITY);

    //*****************************
    // - Tag Hbb jets
    //*****************************
    // Description: Select the two b-tagged jets with highest btagging score as Hbb jets
    vbs.cutflow.addCutToLastActiveCut("TagHiggsJets",
        [&]()
        {
            // get scores and indices pairs
            std::vector<std::pair<float, int>> btag_jets;
            for (unsigned int i = 0; i < vbs.tx.getBranch<vector<LV>>("good_jets_p4").size(); i++)
            {
                const float& btag_score = vbs.tx.getBranch<vector<float>>("good_jets_btag_score")[i];
                btag_jets.push_back(std::make_pair(btag_score, i));
            }

            // Sort the pairs
            std::sort(btag_jets.begin(), btag_jets.end(),
                    [](const std::pair<float, int> & a, const std::pair<float, int> & b) -> bool
                    { 
                        return a.first > b.first;
                    });

            int higgs_jet_0 = btag_jets[0].second < btag_jets[1].second ? btag_jets[0].second : btag_jets[1].second;
            int higgs_jet_1 = btag_jets[0].second < btag_jets[1].second ? btag_jets[1].second : btag_jets[0].second;

            vbs.tx.pushbackToBranch<LV>("higgs_jets_p4", vbs.tx.getBranch<vector<LV>>("good_jets_p4")[higgs_jet_0]);
            vbs.tx.pushbackToBranch<int>("higgs_jets_loose_btagged", vbs.tx.getBranch<vector<int>>("good_jets_loose_btagged")[higgs_jet_0]);
            vbs.tx.pushbackToBranch<int>("higgs_jets_medium_btagged", vbs.tx.getBranch<vector<int>>("good_jets_medium_btagged")[higgs_jet_0]);
            vbs.tx.pushbackToBranch<int>("higgs_jets_tight_btagged", vbs.tx.getBranch<vector<int>>("good_jets_tight_btagged")[higgs_jet_0]);
            vbs.tx.pushbackToBranch<float>("higgs_jets_btag_score", vbs.tx.getBranch<vector<float>>("good_jets_btag_score")[higgs_jet_0]);
            vbs.tx.pushbackToBranch<int>("higgs_jets_good_jets_idx", higgs_jet_0);

            vbs.tx.pushbackToBranch<LV>("higgs_jets_p4", vbs.tx.getBranch<vector<LV>>("good_jets_p4")[higgs_jet_1]);
            vbs.tx.pushbackToBranch<int>("higgs_jets_loose_btagged", vbs.tx.getBranch<vector<int>>("good_jets_loose_btagged")[higgs_jet_1]);
            vbs.tx.pushbackToBranch<int>("higgs_jets_medium_btagged", vbs.tx.getBranch<vector<int>>("good_jets_medium_btagged")[higgs_jet_1]);
            vbs.tx.pushbackToBranch<int>("higgs_jets_tight_btagged", vbs.tx.getBranch<vector<int>>("good_jets_tight_btagged")[higgs_jet_1]);
            vbs.tx.pushbackToBranch<float>("higgs_jets_btag_score", vbs.tx.getBranch<vector<float>>("good_jets_btag_score")[higgs_jet_1]);
            vbs.tx.pushbackToBranch<int>("higgs_jets_good_jets_idx", higgs_jet_1);
            return true;

        }, UNITY);

    //*****************************
    // - Tag VBS jets
    //*****************************
    // Description: Select two jets that are not part of the Hbb jets to be VBS jets with following algorithm
    //              - If all jets are in same hemisphere (eta > 0 or eta < 0) then choose the two leading jets in P (N.B. not pt!)
    //              - If not choose the leading jet in each hemisphere leading in P (N.B. not pt!)
    vbs.cutflow.addCutToLastActiveCut("TagVBSJets",
        [&]()
        {

            // higgs jet indices
            const int& higgs_jet_0 = vbs.tx.getBranch<vector<int>>("higgs_jets_good_jets_idx")[0];
            const int& higgs_jet_1 = vbs.tx.getBranch<vector<int>>("higgs_jets_good_jets_idx")[1];
            // good jets p4
            const vector<LV>& good_jets_p4 = vbs.tx.getBranch<vector<LV>>("good_jets_p4");

            // Select VBS candidates
            std::vector<int> vbs_jet_cands_idxs;
            for (unsigned int i = 0; i < good_jets_p4.size(); i++)
            {
                if ((int) i != higgs_jet_0 and (int) i != higgs_jet_1)
                {
                    if (good_jets_p4[i].pt() >= 30.)
                    {
                        vbs_jet_cands_idxs.push_back(i);
                    }
                }
            }

            if (vbs_jet_cands_idxs.size() < 2)
                return false;

            if (vbs_jet_cands_idxs.size() == 2)
            {
                vbs.tx.pushbackToBranch<LV>("vbs_jets_p4", good_jets_p4[vbs_jet_cands_idxs[0]]);
                vbs.tx.pushbackToBranch<LV>("vbs_jets_p4", good_jets_p4[vbs_jet_cands_idxs[1]]);
                vbs.tx.pushbackToBranch<int>("vbs_jets_good_jets_idx", vbs_jet_cands_idxs[0]);
                vbs.tx.pushbackToBranch<int>("vbs_jets_good_jets_idx", vbs_jet_cands_idxs[1]);
                return true;
            }

            // Otherwise, I have 3 or more vbs candidate jets
            std::vector<std::pair<float, int>> vbs_pos_eta_jets;
            std::vector<std::pair<float, int>> vbs_neg_eta_jets;
            for (unsigned int ijet = 0; ijet < vbs_jet_cands_idxs.size(); ijet++)
            {
                const LV& jet = good_jets_p4[vbs_jet_cands_idxs[ijet]];
                const float& P = good_jets_p4[vbs_jet_cands_idxs[ijet]].P();
                if (jet.eta() >= 0)
                {
                    vbs_pos_eta_jets.push_back(std::make_pair(P, vbs_jet_cands_idxs[ijet]));
                }
                if (jet.eta() < 0)
                {
                    vbs_neg_eta_jets.push_back(std::make_pair(P, vbs_jet_cands_idxs[ijet]));
                }
            }

            // Sort the pairs
            std::sort(vbs_pos_eta_jets.begin(), vbs_pos_eta_jets.end(),
                    [](const std::pair<float, int> & a, const std::pair<float, int> & b) -> bool
                    { 
                    return a.first > b.first;
                    });

            // Sort the pairs
            std::sort(vbs_neg_eta_jets.begin(), vbs_neg_eta_jets.end(),
                    [](const std::pair<float, int> & a, const std::pair<float, int> & b) -> bool
                    { 
                    return a.first > b.first;
                    });

            int vbs_jet_idx_A = -999;
            int vbs_jet_idx_B = -999;
            if (vbs_pos_eta_jets.size() == 0)
            {
                vbs_jet_idx_A = vbs_neg_eta_jets[0].second;
                vbs_jet_idx_B = vbs_neg_eta_jets[1].second;
            }
            else if (vbs_neg_eta_jets.size() == 0)
            {
                vbs_jet_idx_A = vbs_pos_eta_jets[0].second;
                vbs_jet_idx_B = vbs_pos_eta_jets[1].second;
            }
            else
            {
                vbs_jet_idx_A = vbs_pos_eta_jets[0].second;
                vbs_jet_idx_B = vbs_neg_eta_jets[0].second;
            }

            int vbs_jet_idx_0 = vbs_jet_idx_A < vbs_jet_idx_B ? vbs_jet_idx_A : vbs_jet_idx_B;
            int vbs_jet_idx_1 = vbs_jet_idx_A < vbs_jet_idx_B ? vbs_jet_idx_B : vbs_jet_idx_A;

            vbs.tx.pushbackToBranch<LV>("vbs_jets_p4", good_jets_p4[vbs_jet_idx_0]);
            vbs.tx.pushbackToBranch<LV>("vbs_jets_p4", good_jets_p4[vbs_jet_idx_1]);
            vbs.tx.pushbackToBranch<int>("vbs_jets_good_jets_idx", vbs_jet_idx_0);
            vbs.tx.pushbackToBranch<int>("vbs_jets_good_jets_idx", vbs_jet_idx_1);

            return true;

        }, 
        UNITY);

    vbs.cutflow.addCutToLastActiveCut("VBSJetPreselection",
        [&]()
        {
            LV vbs_jet_0 = vbs.tx.getBranch<vector<LV>>("vbs_jets_p4").at(0);
            LV vbs_jet_1 = vbs.tx.getBranch<vector<LV>>("vbs_jets_p4").at(1);
            float M_jj = (vbs_jet_0 + vbs_jet_1).M();
            float deta_jj = vbs_jet_0.eta() - vbs_jet_1.eta();
            return (M_jj >= 500 && fabs(deta_jj) >= 3);
        }, 
        UNITY);

    //*****************************
    // - SR Preselection Dummy Cut Node
    //*****************************
    // Description: This is a dummy cut node to indicate that this node represents where all the SR preselection is applied
    vbs.cutflow.addCutToLastActiveCut("SignalRegionPreselection", UNITY, UNITY);

    vbs.cutflow.bookCutflows();
    vbs.cutflow.bookEventLists();

    // Looping input file
    while (vbs.looper.nextEvent())
    {

        // If splitting jobs are requested then determine whether to process the event or not based on remainder
        if (vbs.job_index != -1 and vbs.nsplit_jobs > 0)
        {
            if (vbs.looper.getNEventsProcessed() % vbs.nsplit_jobs != (unsigned int) vbs.job_index)
                continue;
        }

        vbs.process("SignalRegionPreselection");

    }

    // Writing output file
    vbs.cutflow.saveOutput();

    // Write the data structure to the root file
    vbs.tx.write();

    // The below can be sometimes crucial
    delete vbs.output_tfile;
}
